{"version":3,"file":"ScriptManager.js","names":["EventEmitter","AsyncSeriesBailHook","AsyncSeriesWaterfallHook","NativeScriptManager","Script","getWebpackContext","DEFAULT_RESOLVER_PRIORITY","DEFAULT_RESOLVER_KEY","CACHE_NAME","CACHE_VERSION","CACHE_ENV","__DEV__","CACHE_KEY","join","LOADING_ERROR_CODES","promisify","fn","args","ScriptManager","init","__webpack_require__","repack","shared","scriptManager","cache","scriptsPromises","cacheInitialized","resolvers","constructor","nativeScriptManager","Error","enqueuedResolvers","length","resolver","options","shift","addResolver","hookMap","beforeResolve","resolve","afterResolve","errorResolve","beforeLoad","load","afterLoad","errorLoad","hooks","tapPromise","setStorage","storage","priority","uniqueKey","key","filter","concat","sort","a","b","Number","removeResolver","index","findIndex","item","splice","removeAllResolvers","initCache","cacheEntry","getItem","JSON","parse","saveCache","setItem","stringify","handleError","error","message","console","originalError","resolveScript","__scriptId","__caller","__webpackContext","__referenceUrl","scriptId","caller","referenceUrl","webpackContext","locator","isUsed","promise","emit","resolvedLocator","url","script","createScript","toObject","from","cacheKey","uniqueId","shouldUpdateScript","fetch","shouldUpdateCache","shouldRefetch","updateCache","getCacheData","loadScript","loaded","getScriptUniqueId","isPrefetch","loadProcess","loadScriptWithRetry","code","retry","retryDelay","attempts","includes","Promise","setTimeout","prefetchScript","invalidateScripts","scriptIds","ids","Object","keys","forEach","unstable_evaluateScript","scriptSource","scriptSourceUrl"],"sources":["../../../src/modules/ScriptManager/ScriptManager.ts"],"sourcesContent":["// biome-ignore lint/style/useNodejsImportProtocol: use 'events' module instead of node builtin\nimport EventEmitter from 'events';\nimport { AsyncSeriesBailHook, AsyncSeriesWaterfallHook } from 'tapable';\nimport NativeScriptManager, {\n  type NormalizedScriptLocator,\n} from './NativeScriptManager.js';\nimport { Script } from './Script.js';\nimport { getWebpackContext } from './getWebpackContext.js';\nimport type {\n  ScriptLocator,\n  ScriptLocatorResolver,\n  StorageApi,\n} from './types.js';\n\ntype Cache = Record<\n  string,\n  Pick<NormalizedScriptLocator, 'method' | 'url' | 'query' | 'headers' | 'body'>\n>;\n\ntype ScriptsPromises = Record<\n  string,\n  (Promise<void> & { isPrefetch?: true }) | undefined\n>;\n\nconst DEFAULT_RESOLVER_PRIORITY = 2;\nconst DEFAULT_RESOLVER_KEY = '__default__';\n\nconst CACHE_NAME = 'Repack.ScriptManager.Cache';\nconst CACHE_VERSION = 'v4';\nconst CACHE_ENV = __DEV__ ? 'debug' : 'release';\n\nconst CACHE_KEY = [CACHE_NAME, CACHE_VERSION, CACHE_ENV].join('.');\n\nconst LOADING_ERROR_CODES = [\n  // android\n  'NetworkFailure',\n  'RequestFailure',\n  // ios\n  'ScriptDownloadFailure',\n];\n\ntype MaybePromise<T> = T | Promise<T>;\n\nfunction promisify<T extends (...args: any[]) => any>(fn: T) {\n  return async (...args: Parameters<T>) => fn(...args);\n}\n\n/* Options for resolver when adding it to a `ScriptManager`. */\nexport interface ResolverOptions {\n  /**\n   * Priority of the resolver. Defaults to `2`.\n   * Resolvers are called based on the highest priority,\n   * so higher the number, the higher priority the resolver gets.\n   */\n  priority?: number;\n  /**\n   * Unique key to identify the resolver.\n   * If not provided, the resolver will be added unconditionally.\n   * If provided, the new resolver will be replace the existing one configured with the same `uniqueKey`.\n   */\n  key?: string;\n}\n\ninterface ResolveScriptOptions {\n  scriptId: string;\n  caller?: string;\n  webpackContext: RepackRuntimeGlobals.WebpackRequire;\n  referenceUrl?: string;\n}\n\ninterface LoadScriptOptions extends ResolveScriptOptions {}\n\ninterface ResolveHookOptions {\n  options: ResolveScriptOptions;\n  resolvers: Array<[string, string | number, ScriptLocatorResolver]>;\n}\n\ninterface BeforeResolveHookOptions {\n  options: ResolveScriptOptions;\n}\n\ninterface AfterResolveHookOptions {\n  options: ResolveScriptOptions;\n  locator: ScriptLocator;\n}\n\ninterface ErrorResolveHookOptions {\n  options: ResolveScriptOptions;\n  error: Error;\n}\n\ninterface BeforeLoadHookOptions {\n  options: LoadScriptOptions;\n  script: Script;\n}\n\ninterface LoadHookOptions {\n  options: LoadScriptOptions;\n  script: Script;\n  loadScript: (\n    scriptId?: string,\n    locator?: NormalizedScriptLocator & { retryDelay?: number; retry?: number }\n  ) => Promise<void>;\n}\n\ninterface AfterLoadHookOptions {\n  options: LoadScriptOptions;\n  script: Script;\n}\n\ninterface ErrorLoadHookOptions {\n  options: LoadScriptOptions;\n  error: Error;\n}\n\n/**\n * A manager to ease resolution, downloading and executing additional code from:\n * - arbitrary JavaScript scripts\n * - Webpack chunks\n * - Webpack bundles\n * - Webpack MF containers\n *\n * ScriptManager is globally available under `ScriptManager.shared` in main bundle, chunks and containers.\n *\n * Use `ScriptManager.shared` instead of creating new instance of `ScriptManager`.\n *\n * This API is mainly useful, if you are working with any form of Code Splitting.\n *\n * `ScriptManager` is also an `EventEmitter` and emits the following events:\n * - `resolving` with `{ scriptId, caller }`\n * - `resolved` with `scriptId: string, caller?: string, locator: NormalizedScriptLocator, cache: boolean`\n * - `prefetching` with `scriptId: string, caller?: string, locator: NormalizedScriptLocator, cache: boolean`\n * - `loading` with `scriptId: string, caller?: string, locator: NormalizedScriptLocator, cache: boolean`\n * - `loaded` with `scriptId: string, caller?: string, locator: NormalizedScriptLocator, cache: boolean`\n * - `error` with `error: Error`\n *\n * Example of using this API with async Webpack chunk:\n * ```js\n * import * as React from 'react';\n * import { ScriptManager, Script } from '@callstack/repack/client';\n *\n * ScriptManager.shared.addResolver(async (scriptId) => {\n *   if (__DEV__) {\n *     return {\n *       url: Script.getDevServerURL(scriptId);\n *       cache: false,\n *     };\n *   }\n *\n *   return {\n *     url: Script.getRemoteURL(`http://domain.exaple/apps/${scriptId}`),\n *   };\n * });\n *\n * // ScriptManager.shared.loadScript is called internally when running `import()`\n * const TeacherModule = React.lazy(() => import('./Teacher.js'));\n * const StudentModule = React.lazy(() => import('./Student.js'));\n *\n * export function App({ role }) {\n *   if (role === 'teacher') {\n *     return <TeacherModule />;\n *   }\n *\n *   return <StudentModule />\n * }\n * ```\n */\nexport class ScriptManager extends EventEmitter {\n  static init() {\n    if (!__webpack_require__.repack.shared.scriptManager) {\n      __webpack_require__.repack.shared.scriptManager = new ScriptManager();\n    }\n  }\n\n  static get shared(): ScriptManager {\n    return __webpack_require__.repack.shared.scriptManager!;\n  }\n\n  protected cache: Cache = {};\n  protected scriptsPromises: ScriptsPromises = {};\n  protected cacheInitialized = false;\n  protected resolvers: Array<[string, string | number, ScriptLocatorResolver]> =\n    [];\n  protected storage?: StorageApi;\n\n  /**\n   * Constructs instance of `ScriptManager`.\n   *\n   * __Should not be called directly__ - use `ScriptManager.shared`.\n   *\n   * @internal\n   */\n  protected constructor(private nativeScriptManager = NativeScriptManager) {\n    super();\n\n    if (!nativeScriptManager) {\n      throw new Error(\n        'repack react-native module was not found.' +\n          (__DEV__ ? ' Did you forget to update native dependencies?' : '')\n      );\n    }\n\n    if (__webpack_require__.repack.shared.scriptManager) {\n      throw new Error(\n        'ScriptManager was already instantiated. Use ScriptManager.shared instead.'\n      );\n    }\n\n    __webpack_require__.repack.shared.scriptManager = this;\n\n    const enqueuedResolvers =\n      __webpack_require__.repack.shared.enqueuedResolvers;\n    while (enqueuedResolvers.length) {\n      // process deferred resolvers in First-In-First-Out (FIFO) order to maintain\n      // the sequence in which they were registered before ScriptManager initialization\n      const [resolver, options] = enqueuedResolvers.shift()!;\n      this.addResolver(resolver, options);\n    }\n  }\n\n  private hookMap = {\n    beforeResolve: new AsyncSeriesWaterfallHook<\n      BeforeResolveHookOptions,\n      BeforeResolveHookOptions\n    >(['args']),\n    resolve: new AsyncSeriesBailHook<\n      ResolveHookOptions,\n      ScriptLocator | undefined\n    >(['args']),\n    afterResolve: new AsyncSeriesWaterfallHook<\n      AfterResolveHookOptions,\n      AfterResolveHookOptions\n    >(['args']),\n    errorResolve: new AsyncSeriesBailHook<\n      ErrorResolveHookOptions,\n      ScriptLocator | undefined\n    >(['args']),\n    beforeLoad: new AsyncSeriesWaterfallHook<\n      BeforeLoadHookOptions,\n      BeforeLoadHookOptions\n    >(['args']),\n    load: new AsyncSeriesBailHook<LoadHookOptions, boolean>(['args']),\n    afterLoad: new AsyncSeriesWaterfallHook<\n      AfterLoadHookOptions,\n      AfterLoadHookOptions\n    >(['args']),\n    errorLoad: new AsyncSeriesBailHook<ErrorLoadHookOptions, boolean>(['args']),\n  };\n\n  public hooks = {\n    beforeResolve: (\n      fn: (\n        args: BeforeResolveHookOptions\n      ) => MaybePromise<BeforeResolveHookOptions>\n    ) => this.hookMap.beforeResolve.tapPromise('beforeResolve', promisify(fn)),\n    resolve: (\n      fn: (args: ResolveHookOptions) => MaybePromise<ScriptLocator | undefined>\n    ) => this.hookMap.resolve.tapPromise('resolve', promisify(fn)),\n    afterResolve: (\n      fn: (\n        args: AfterResolveHookOptions\n      ) => MaybePromise<AfterResolveHookOptions>\n    ) => this.hookMap.afterResolve.tapPromise('afterResolve', promisify(fn)),\n    errorResolve: (\n      fn: (\n        args: ErrorResolveHookOptions\n      ) => MaybePromise<ScriptLocator | undefined | void>\n    ) => this.hookMap.errorResolve.tapPromise('errorResolve', promisify(fn)),\n    beforeLoad: (\n      fn: (args: BeforeLoadHookOptions) => MaybePromise<BeforeLoadHookOptions>\n    ) => this.hookMap.beforeLoad.tapPromise('beforeLoad', promisify(fn)),\n    load: (fn: (args: LoadHookOptions) => MaybePromise<boolean>) =>\n      this.hookMap.load.tapPromise('load', promisify(fn)),\n    afterLoad: (\n      fn: (args: AfterLoadHookOptions) => MaybePromise<AfterLoadHookOptions>\n    ) => this.hookMap.afterLoad.tapPromise('afterLoad', promisify(fn)),\n    errorLoad: (\n      fn: (\n        args: ErrorLoadHookOptions\n      ) => MaybePromise<boolean | undefined | void>\n    ) => this.hookMap.errorLoad.tapPromise('errorLoad', promisify(fn)),\n  };\n\n  /**\n   * Sets a storage backend to cache resolved scripts locator data.\n   *\n   * The stored data is used to detect if scripts locator data of previously downloaded\n   * script hasn't changed to avoid over-fetching the script.\n   *\n   * @param storage Implementation of storage functions.\n   */\n  setStorage(storage?: StorageApi) {\n    this.storage = storage;\n  }\n\n  /**\n   * Adds new script locator resolver.\n   *\n   * Resolver is an async function to resolve script locator data - in other words, it's a function to\n   * tell the {@link ScriptManager} how to fetch the script.\n   *\n   * There's no limitation on what logic you can run inside this function - it can include:\n   * - fetching/loading remote config\n   * - fetching/loading feature flags\n   * - fetching/loading A/B testing data\n   * - calling native modules\n   * - running arbitrary logic\n   *\n   * @param resolver Resolver function to add.\n   * @param options Resolver options.\n   */\n  addResolver(resolver: ScriptLocatorResolver, options: ResolverOptions = {}) {\n    const priority = options.priority ?? DEFAULT_RESOLVER_PRIORITY;\n    const uniqueKey = options.key;\n\n    this.resolvers = this.resolvers\n      .filter(([key]) => key !== uniqueKey)\n      .concat([[uniqueKey ?? DEFAULT_RESOLVER_KEY, priority, resolver]])\n      .sort(([, a], [, b]) => Number(b) - Number(a));\n  }\n\n  /**\n   * Removes previously added resolver.\n   *\n   * @param resolver Resolver function or resolver's `uniqueKey` to remove.\n   * @returns `true` if resolver was found and removed, `false` otherwise.\n   */\n  removeResolver(resolver: ScriptLocatorResolver | string): boolean {\n    let index: number;\n    if (typeof resolver === 'string') {\n      index = this.resolvers.findIndex(([key]) => key === resolver);\n    } else {\n      index = this.resolvers.findIndex(([, , item]) => item === resolver);\n    }\n\n    if (index > -1) {\n      this.resolvers.splice(index, 1);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Removes all previously added resolvers.\n   */\n  removeAllResolvers() {\n    this.resolvers = [];\n  }\n\n  protected async initCache() {\n    if (!this.cacheInitialized) {\n      const cacheEntry = await this.storage?.getItem(CACHE_KEY);\n      this.cache = cacheEntry ? JSON.parse(cacheEntry) : {};\n      this.cacheInitialized = true;\n    }\n  }\n\n  protected async saveCache() {\n    await this.storage?.setItem(CACHE_KEY, JSON.stringify(this.cache));\n  }\n\n  protected handleError(error: any, message: string, ...args: any[]) {\n    console.error(message, ...args, { originalError: error });\n    // this.emit('error', { message, args, originalError: error });\n    // throw error;\n  }\n\n  /**\n   * Resolves a {@link Script} instance with normalized locator data.\n   *\n   * Resolution will use previously added (via `ScriptManager.shared.addResolver(...)`) resolvers\n   * in series, util one returns a locator data or will throw if no resolver handled the request.\n   *\n   * Use `ScriptManager.shared.on('resolving', ({ scriptId, caller }) => { })` to listen for when\n   * the script resolution begins.\n   *\n   * Use `ScriptManager.shared.on('resolved', (script) => { })` to listen for when\n   * the script's locator data is resolved.\n   *\n   * @param scriptId Id of the script to resolve.\n   * @param caller Name of the calling script - it can be for example: name of the bundle, chunk or container.\n   */\n  async resolveScript(\n    scriptId: string,\n    caller?: string,\n    webpackContext?: RepackRuntimeGlobals.WebpackRequire,\n    referenceUrl?: string\n  ): Promise<any>;\n\n  // NOTE: Keep declaration and implementation separate\n  // to allow for better naming in JSDocs while preventing\n  // using the arguments directly in the implementation\n  async resolveScript(\n    __scriptId: string,\n    __caller?: string,\n    __webpackContext = getWebpackContext(),\n    __referenceUrl?: string\n  ): Promise<any> {\n    let options: ResolveScriptOptions = {\n      scriptId: __scriptId,\n      caller: __caller,\n      referenceUrl: __referenceUrl,\n      webpackContext: __webpackContext,\n    };\n\n    let locator: ScriptLocator | undefined;\n\n    try {\n      await this.initCache();\n\n      if (!this.resolvers.length) {\n        throw new Error(\n          'No script resolvers were added. Did you forget to call `ScriptManager.shared.addResolver(...)`?'\n        );\n      }\n\n      if (this.hookMap.beforeResolve.isUsed()) {\n        ({ options } = await this.hookMap.beforeResolve.promise({ options }));\n      }\n\n      this.emit('resolving', {\n        scriptId: options.scriptId,\n        caller: options.caller,\n      });\n\n      if (this.hookMap.resolve.isUsed()) {\n        // obtain the result from custom implementation through the resolve hook\n        locator = await this.hookMap.resolve.promise({\n          options,\n          resolvers: this.resolvers,\n        });\n      } else {\n        // obtain the result from default implementation\n        for (const [, , resolve] of this.resolvers) {\n          const resolvedLocator = await resolve(\n            options.scriptId,\n            options.caller,\n            options.referenceUrl\n          );\n          if (resolvedLocator) {\n            locator = resolvedLocator;\n            break;\n          }\n        }\n      }\n\n      if (!locator) {\n        throw new Error(\n          `No resolver was able to resolve script ${options.scriptId}`\n        );\n      }\n\n      if (this.hookMap.afterResolve.isUsed()) {\n        ({ options, locator } = await this.hookMap.afterResolve.promise({\n          options,\n          locator,\n        }));\n      }\n\n      if (typeof locator.url === 'function') {\n        locator.url = locator.url(options.webpackContext);\n      }\n    } catch (error) {\n      locator = await this.hookMap.errorResolve.promise({\n        options,\n        error: error as Error,\n      });\n\n      \n      if (!locator) {\n        this.handleError(\n          error,\n          '[ScriptManager] Failed while resolving script locator:',\n          { scriptId: options.scriptId, caller: options.caller }\n        );\n      }\n    }\n\n    try {\n      const script = await this.createScript(\n        options.scriptId,\n        options.caller,\n        // @ts-expect-error\n        locator\n      );\n      this.emit('resolved', script.toObject());\n      return script;\n    } catch (error) {\n      this.handleError(error, '[ScriptManager] Failed while creating script:', {\n        scriptId: options.scriptId,\n        caller: options.caller,\n      });\n    }\n  }\n\n  private async createScript(\n    scriptId: string,\n    caller: string | undefined,\n    locator: ScriptLocator\n  ) {\n    const script = Script.from({ scriptId, caller }, locator, false);\n    const cacheKey = script.locator.uniqueId;\n\n    // Check if user provided a custom shouldUpdateScript function\n    if (locator.shouldUpdateScript) {\n      // If so, we need to wait for it to resolve\n      const fetch = await locator.shouldUpdateScript(\n        scriptId,\n        caller,\n        script.shouldUpdateCache(this.cache[cacheKey])\n      );\n\n      // If it returns true, we need to fetch the script\n      if (fetch) {\n        script.locator.fetch = true;\n      }\n      \n    } else {\n      // If no custom shouldUpdateScript function was provided, we use the default behaviour\n      if (!this.cache[cacheKey]) {\n        script.locator.fetch = true;\n      } else if (script.shouldRefetch(this.cache[cacheKey])) {\n        script.locator.fetch = true;\n      }\n    }\n\n    return script;\n  }\n\n  private async updateCache(script: Script) {\n    if (script.locator.fetch) {\n      const cacheKey = script.locator.uniqueId;\n      this.cache[cacheKey] = script.getCacheData();\n      await this.saveCache();\n    }\n  }\n\n  /**\n   * Resolves given script's location, downloads and executes it.\n   * The execution of the code is handled internally by threading in React Native.\n   *\n   * Use `ScriptManager.shared.on('loading', (script) => { })` to listen for when\n   * the script is about to be loaded.\n   *\n   * Use `ScriptManager.shared.on('loaded', (script) => { })` to listen for when\n   * the script is loaded.\n   *\n   * @param scriptId Id of the script to load.\n   * @param caller Name of the calling script - it can be for example: name of the bundle, chunk or container.\n   */\n  async loadScript(\n    scriptId: string,\n    caller?: string,\n    webpackContext?: RepackRuntimeGlobals.WebpackRequire,\n    referenceUrl?: string\n  ): Promise<void>;\n\n  // NOTE: Keep declaration and implementation separate\n  // to allow for better naming in JSDocs while preventing\n  // using the arguments directly in the implementation\n  async loadScript(\n    __scriptId: string,\n    __caller?: string,\n    __webpackContext = getWebpackContext(),\n    __referenceUrl?: string\n  ) {\n    let options: LoadScriptOptions = {\n      scriptId: __scriptId,\n      caller: __caller,\n      referenceUrl: __referenceUrl,\n      webpackContext: __webpackContext,\n    };\n\n    let loaded = false;\n\n    const uniqueId = Script.getScriptUniqueId(options.scriptId, options.caller);\n\n    if (this.scriptsPromises[uniqueId]) {\n      const { isPrefetch } = this.scriptsPromises[uniqueId];\n\n      // prefetch is not execute the script so we need to run loadScript if promise is for prefetch\n      if (isPrefetch) {\n        await this.scriptsPromises[uniqueId];\n      } else {\n        return this.scriptsPromises[uniqueId];\n      }\n    }\n\n    const loadProcess = async () => {\n      let script = await this.resolveScript(\n        options.scriptId,\n        options.caller,\n        options.webpackContext,\n        options.referenceUrl\n      );\n      if (!script) {\n        return;\n      }\n\n      try {\n        if (this.hookMap.beforeLoad.isUsed()) {\n          ({ options, script } = await this.hookMap.beforeLoad.promise({\n            options,\n            script,\n          }));\n        }\n\n        this.emit('loading', script.toObject());\n\n        if (this.hookMap.load.isUsed()) {\n          loaded = await this.hookMap.load.promise({\n            options,\n            script,\n            loadScript: async (\n              scriptId = options.scriptId,\n              locator = script.locator\n            ) => {\n              await this.loadScriptWithRetry(scriptId, locator);\n            },\n          });\n        } else {\n          await this.loadScriptWithRetry(options.scriptId, script.locator);\n          loaded = true;\n        }\n\n        if (this.hookMap.afterLoad.isUsed()) {\n          ({ options, script } = await this.hookMap.afterLoad.promise({\n            options,\n            script,\n          }));\n        }\n\n        this.emit('loaded', script.toObject());\n        await this.updateCache(script);\n      } catch (error) {\n        const { code } = error as Error & { code: string };\n        loaded = await this.hookMap.errorLoad.promise({\n          options,\n          error: error as Error,\n        });\n        if (!loaded) {\n          this.handleError(\n            error,\n            '[ScriptManager] Failed to load script:',\n            code ? `[${code}]` : '',\n            script.toObject()\n          );\n        }\n      } finally {\n        // should delete script promise even script failed\n        delete this.scriptsPromises[uniqueId];\n      }\n    };\n\n    this.scriptsPromises[uniqueId] = loadProcess();\n    return this.scriptsPromises[uniqueId];\n  }\n\n  /**\n   * Loads a script with retry logic.\n   *\n   * This function attempts to load a script using the nativeScriptManager.\n   * If the initial attempt fails, it retries the specified number of times\n   * with an optional delay between retries.\n   *\n   * @param {string} scriptId - The ID of the script to load.\n   * @param {NormalizedScriptLocator} locator - An NormalizedScriptLocator containing retry configuration.\n   * @param {number} [locator.retry=0] - The number of retry attempts.\n   * @param {number} [locator.retryDelay=0] - The delay in milliseconds between retries.\n   * @throws {Error} Throws an error if all retry attempts fail.\n   */\n  protected async loadScriptWithRetry(\n    scriptId: string,\n    locator: NormalizedScriptLocator & { retryDelay?: number; retry?: number }\n  ) {\n    const { retry = 0, retryDelay = 0 } = locator;\n    let attempts = retry + 1; // Include the initial attempt\n\n    while (attempts > 0) {\n      try {\n        await this.nativeScriptManager.loadScript(scriptId, locator);\n        return; // Successfully loaded the script, exit the loop\n      } catch (error) {\n        attempts--;\n        const { code } = error as Error & { code: string };\n        if (attempts > 0 && LOADING_ERROR_CODES.includes(code)) {\n          if (retryDelay > 0) {\n            await new Promise((resolve) => setTimeout(resolve, retryDelay));\n          }\n        } else {\n          throw error; // No more retries, throw the error\n        }\n      }\n    }\n  }\n\n  /**\n   * Resolves given script's location and downloads it without executing.\n   * This function can be awaited to detect if the script was downloaded and for error handling.\n   *\n   * Use `ScriptManager.shared.on('prefetching', (script) => { })` to listen for when\n   * the script's prefetch beings.\n   *\n   * @param scriptId Id of the script to prefetch.\n   * @param caller Name of the calling script - it can be for example: name of the bundle, chunk or container.\n   */\n  async prefetchScript(\n    scriptId: string,\n    caller?: string,\n    webpackContext = getWebpackContext(),\n    referenceUrl?: string\n  ) {\n    const uniqueId = Script.getScriptUniqueId(scriptId, caller);\n    if (this.scriptsPromises[uniqueId]) {\n      return this.scriptsPromises[uniqueId];\n    }\n    const loadProcess = async () => {\n      const script = await this.resolveScript(\n        scriptId,\n        caller,\n        webpackContext,\n        referenceUrl\n      );\n\n      try {\n        this.emit('prefetching', script.toObject());\n        await this.nativeScriptManager.prefetchScript(scriptId, script.locator);\n        await this.updateCache(script);\n      } catch (error) {\n        const { code } = error as Error & { code: string };\n        this.handleError(\n          error,\n          '[ScriptManager] Failed to prefetch script:',\n          code ? `[${code}]` : '',\n          script.toObject()\n        );\n      } finally {\n        // should delete script promise even script failed\n        delete this.scriptsPromises[uniqueId];\n      }\n    };\n\n    this.scriptsPromises[uniqueId] = loadProcess();\n    this.scriptsPromises[uniqueId].isPrefetch = true;\n    return this.scriptsPromises[uniqueId];\n  }\n\n  /**\n   * Clears the cache (if configured in {@link ScriptManager.setStorage}) and removes downloaded\n   * files for given scripts from the filesystem. This function can be awaited to detect if the\n   * scripts were invalidated and for error handling.\n   *\n   * Use `ScriptManager.shared.on('invalidated', (scriptIds) => { })` to listen for when\n   * the invalidation completes.\n   *\n   * @param scriptIds Array of script ids to clear from cache and remove from filesystem.\n   * @returns Array of script ids that were invalidated.\n   */\n  async invalidateScripts(scriptIds: string[]) {\n    try {\n      await this.initCache();\n\n      const ids = scriptIds.length ? scriptIds : Object.keys(this.cache);\n      ids.forEach((scriptId) => {\n        delete this.cache[scriptId];\n        delete this.scriptsPromises[scriptId];\n      });\n\n      await this.saveCache();\n      await this.nativeScriptManager.invalidateScripts(ids);\n\n      this.emit('invalidated', ids);\n      return ids;\n    } catch (error) {\n      const { code } = error as Error & { code: string };\n      this.handleError(\n        error,\n        '[ScriptManager] Failed to invalidate scripts:',\n        code ? `[${code}]` : ''\n      );\n    }\n  }\n\n  /**\n   * Evaluates a script synchronously.\n   *\n   * This function sends the script source and its URL to the native script manager for evaluation.\n   * It is functionally identical to `globalEvalWithSourceUrl`.\n   *\n   * @param scriptSource The source code of the script to evaluate.\n   * @param scriptSourceUrl The URL of the script source, used for debugging purposes.\n   */\n  unstable_evaluateScript(scriptSource: string, scriptSourceUrl: string) {\n    this.nativeScriptManager.unstable_evaluateScript(\n      scriptSource,\n      scriptSourceUrl\n    );\n  }\n}\n"],"mappings":"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","ignoreList":[]}