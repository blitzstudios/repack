{"version":3,"sources":["../../../../src/webpack/plugins/utils/AssetsCopyProcessor.ts"],"names":["AssetsCopyProcessor","constructor","config","filesystem","fs","copyAsset","from","to","logger","debug","ensureDir","path","dirname","copyFile","enqueueChunk","chunk","isEntry","compilation","outputPath","bundleOutput","sourcemapOutput","bundleOutputDir","assetsDest","platform","sourcemapOutputDir","chunkFile","files","relatedSourceMap","assetsInfo","get","related","sourceMap","sourceMapFile","Array","isArray","bundleDestination","join","sourceMapDestination","shouldOverrideMappingInfo","chunkSource","queue","push","bundleContent","readFile","writeFile","replace","basename","sourceMapSource","sourceMapContent","mediaAssets","auxiliaryFiles","filter","file","test","map","asset","manifest","manifestSource","manifestDestination","manifestContent","execute","work"],"mappings":"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","sourcesContent":["import path from 'path';\nimport fs from 'fs-extra';\nimport webpack from 'webpack';\nimport { WebpackLogger } from '../../../types';\n\nexport class AssetsCopyProcessor {\n  queue: Array<() => Promise<void>> = [];\n\n  constructor(\n    public readonly config: {\n      platform: string;\n      compilation: webpack.Compilation;\n      outputPath: string;\n      bundleOutput: string;\n      bundleOutputDir: string;\n      sourcemapOutput: string;\n      assetsDest: string;\n      logger: WebpackLogger;\n    },\n    private filesystem: Pick<\n      typeof fs,\n      'ensureDir' | 'copyFile' | 'readFile' | 'writeFile'\n    > = fs\n  ) {}\n\n  private async copyAsset(from: string, to: string) {\n    this.config.logger.debug('Copying asset:', from, 'to:', to);\n    await this.filesystem.ensureDir(path.dirname(to));\n    await this.filesystem.copyFile(from, to);\n  }\n\n  enqueueChunk(chunk: webpack.Chunk, { isEntry }: { isEntry: boolean }) {\n    const {\n      compilation,\n      outputPath,\n      bundleOutput,\n      sourcemapOutput,\n      bundleOutputDir,\n      assetsDest,\n      platform,\n    } = this.config;\n    const sourcemapOutputDir = sourcemapOutput\n      ? path.dirname(sourcemapOutput)\n      : bundleOutputDir;\n\n    // Chunk bundle e.g: `index.bundle`, `src_App_js.chunk.bundle`\n    const [chunkFile] = [...chunk.files];\n    const relatedSourceMap =\n      compilation.assetsInfo.get(chunkFile)?.related?.sourceMap;\n    // Source map for the chunk e.g: `index.bundle.map`, `src_App_js.chunk.bundle.map`\n    const sourceMapFile = Array.isArray(relatedSourceMap)\n      ? relatedSourceMap[0]\n      : relatedSourceMap;\n\n    // Target file path where to save the bundle.\n    const bundleDestination = isEntry\n      ? bundleOutput\n      : path.join(platform === 'ios' ? assetsDest : bundleOutputDir, chunkFile);\n\n    // Target file path where to save the source map file.\n    const sourceMapDestination = isEntry\n      ? sourcemapOutput\n      : path.join(\n          platform === 'ios' ? assetsDest : sourcemapOutputDir,\n          sourceMapFile ?? ''\n        );\n\n    // Entry chunks (main/index bundle) need to be processed differently to\n    // adjust file name and the content of source mapping info to match values provided by:\n    // - `--bundle-output` -> `bundleOutput`\n    // - `--sourcemap-output` -> `sourcemapOutput`\n    const shouldOverrideMappingInfo = isEntry && sourceMapFile;\n\n    // Absolute path to chunk bundle file saved in `output.path`\n    const chunkSource = path.join(outputPath, chunkFile);\n\n    // If chunk is an entry chunk, meaning it's a main/index bundle,\n    // save it based on `bundleDestination` and overwrite `sourceMappingURL`\n    // to point to correct file name (e.g: `index.bundle.map` -> `main.jsbundle.map`).\n    // Otherwise, simply copy the file to it's target `bundleDestination`.\n    if (shouldOverrideMappingInfo) {\n      this.queue.push(async () => {\n        const bundleContent = await this.filesystem.readFile(\n          chunkSource,\n          'utf-8'\n        );\n        await this.filesystem.ensureDir(path.dirname(bundleDestination));\n        await this.filesystem.writeFile(\n          bundleDestination,\n          bundleContent.replace(\n            /\\/\\/# sourceMappingURL=.*$/,\n            `//# sourceMappingURL=${path.basename(sourceMapDestination)}`\n          )\n        );\n      });\n    } else {\n      this.queue.push(() => this.copyAsset(chunkSource, bundleDestination));\n    }\n\n    if (sourceMapFile) {\n      const sourceMapSource = path.join(outputPath, sourceMapFile);\n\n      // If chunk is an entry chunk, meaning it's a main/index bundle,\n      // save the source map file for it based on `sourceMapDestination` and values inside it,\n      // to point to a correct bundle file name (e.g: `index.bundle` -> `main.jsbundle`).\n      // Otherwise, simply copy the file to it's target `sourceMapDestination`.\n      if (isEntry) {\n        this.queue.push(async () => {\n          const sourceMapContent = await this.filesystem.readFile(\n            sourceMapSource,\n            'utf-8'\n          );\n          await this.filesystem.ensureDir(path.dirname(sourceMapDestination));\n          await this.filesystem.writeFile(\n            sourceMapDestination,\n            sourceMapContent.replace(\n              chunkFile,\n              path.basename(bundleDestination)\n            )\n          );\n        });\n      } else {\n        this.queue.push(() =>\n          this.copyAsset(sourceMapSource, sourceMapDestination)\n        );\n      }\n    }\n\n    // Copy regular assets\n    const mediaAssets = [...chunk.auxiliaryFiles].filter(\n      (file) => !/\\.(map|bundle\\.json)$/.test(file)\n    );\n    this.queue.push(\n      ...mediaAssets.map(\n        (asset) => () =>\n          this.copyAsset(\n            path.join(outputPath, asset),\n            path.join(assetsDest, asset)\n          )\n      )\n    );\n\n    // Manifest file name e.g: `index.bundle.json`, src_App_js.chunk.bundle.json`\n    const [manifest] = [...chunk.auxiliaryFiles].filter((file) =>\n      /\\.bundle\\.json$/.test(file)\n    );\n    if (manifest) {\n      const manifestSource = path.join(outputPath, manifest);\n      const manifestDestination = path.join(\n        platform === 'ios' ? assetsDest : bundleOutputDir,\n        isEntry ? `${path.basename(bundleDestination)}.json` : manifest\n      );\n\n      // If chunk is an entry chunk, meaning it's a main bundle,\n      // adjust chunk and source map names inside the manifest (e.g: `index.bundle` -> `main.jsbundle`,\n      // `index.bundle.map` -> `main.jsbundle.map`).\n      // Otherwise, simply copy the manifest.\n      if (isEntry) {\n        this.queue.push(async () => {\n          const manifestContent = await this.filesystem.readFile(\n            manifestSource,\n            'utf-8'\n          );\n          await this.filesystem.ensureDir(path.dirname(manifestDestination));\n          await this.filesystem.writeFile(\n            manifestDestination,\n            manifestContent\n              .replace(chunkFile, path.basename(bundleDestination))\n              .replace(\n                sourceMapFile ?? /.^/,\n                path.basename(sourceMapDestination)\n              )\n          );\n        });\n      } else {\n        this.queue.push(() =>\n          this.copyAsset(manifestSource, manifestDestination)\n        );\n      }\n    }\n  }\n\n  execute() {\n    const queue = this.queue;\n    this.queue = [];\n    return queue.map((work) => work());\n  }\n}\n"],"file":"AssetsCopyProcessor.js"}